'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactViewportUtils = require('react-viewport-utils');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var StickyGroupContext = React.createContext({
    stickyOffset: { top: 0, height: 0 },
    updateStickyOffset: function (offset, height) { },
});
var connect = function () { return function (WrappedComponent) {
    var ConnectedComponent = function (props) { return (React.createElement(StickyGroupContext.Consumer, null, function (context) { return (React.createElement(WrappedComponent, __assign({}, props, { stickyOffset: context.stickyOffset, updateStickyOffset: context.updateStickyOffset }))); })); };
    var displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    ConnectedComponent.displayName = "connectSticky(" + displayName + ")";
    return ConnectedComponent;
}; };
var StickyScrollUpProvider = /** @class */ (function (_super) {
    __extends(StickyScrollUpProvider, _super);
    function StickyScrollUpProvider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stickyOffset = {
            top: 0,
            height: 0,
        };
        _this.updateStickyOffset = function (stickyOffset, height) {
            _this.stickyOffset.top = Math.min(stickyOffset, height);
            _this.stickyOffset.height = height;
        };
        return _this;
    }
    StickyScrollUpProvider.prototype.render = function () {
        return (React.createElement(reactViewportUtils.ViewportProvider, { experimentalSchedulerEnabled: true },
            React.createElement(StickyGroupContext.Provider, { value: {
                    updateStickyOffset: this.updateStickyOffset,
                    stickyOffset: this.stickyOffset,
                } }, this.props.children)));
    };
    return StickyScrollUpProvider;
}(React.PureComponent));

var baseStyles = {
    width: 'inherit',
};
var prefixTransform = function (transform) { return ({
    transform: transform,
    WebkitTransform: transform,
    msTransform: transform,
    OTransform: transform,
}); };
var StickyElement = function (_a) {
    var children = _a.children, forwardRef = _a.forwardRef, _b = _a.style, overrideStyles = _b === void 0 ? {} : _b, _c = _a.positionStyle, positionStyle = _c === void 0 ? {} : _c, disabled = _a.disabled, renderArgs = _a.renderArgs, props = __rest(_a, ["children", "forwardRef", "style", "positionStyle", "disabled", "renderArgs"]);
    var style = !disabled
        ? __assign(__assign(__assign({}, baseStyles), positionStyle), overrideStyles) : {};
    if (style.transform) {
        Object.assign(style, prefixTransform(style.transform));
    }
    return (React.createElement("div", __assign({ ref: forwardRef, style: style }, props), typeof children === 'function'
        ? children(renderArgs)
        : children));
};

var ElementResizeObserver = /** @class */ (function (_super) {
    __extends(ElementResizeObserver, _super);
    function ElementResizeObserver(props) {
        var _this = _super.call(this, props) || this;
        _this.resizeObserver = null;
        return _this;
    }
    ElementResizeObserver.prototype.componentDidMount = function () {
        this.resetObserver();
        this.installObserver();
    };
    ElementResizeObserver.prototype.componentDidUpdate = function () {
        this.resetObserver();
        this.installObserver();
    };
    ElementResizeObserver.prototype.componentWillUnmount = function () {
        this.resetObserver();
    };
    ElementResizeObserver.prototype.installObserver = function () {
        var _this = this;
        if (!this.props.stickyRef.current) {
            return;
        }
        if (typeof window.ResizeObserver !== 'undefined') {
            this.resizeObserver = new window.ResizeObserver(function (entries) {
                if (entries && entries[0] && entries[0].contentRect) {
                    _this.props.onUpdate(entries[0].contentRect);
                }
            });
            this.resizeObserver.observe(this.props.stickyRef.current);
        }
    };
    ElementResizeObserver.prototype.resetObserver = function () {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
    };
    ElementResizeObserver.prototype.render = function () {
        return null;
    };
    return ElementResizeObserver;
}(React.PureComponent));

var StickyPlaceholder = /** @class */ (function (_super) {
    __extends(StickyPlaceholder, _super);
    function StickyPlaceholder() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isRecalculating: false,
            isWaitingForRecalculation: false,
            stickyHeight: null,
            stickyWidth: null,
            clientHash: null,
        };
        _this.calculateSize = function () {
            if (_this.props.stickyRef.current &&
                !_this.state.isRecalculating &&
                _this.state.isWaitingForRecalculation) {
                return _this.props.stickyRef.current.getBoundingClientRect();
            }
            return null;
        };
        _this.handleDimensionsUpdate = function (_a, stickyRect) {
            var dimensions = _a.dimensions;
            if (_this.isUnmounted) {
                return;
            }
            _this.lastDimensions = dimensions;
            var width = dimensions.width, clientWidth = dimensions.clientWidth;
            var nextClientHash = [width, clientWidth].join(',');
            if (!_this.state.isWaitingForRecalculation &&
                _this.state.clientHash !== nextClientHash) {
                _this.setState({
                    clientHash: nextClientHash,
                    isRecalculating: true,
                    isWaitingForRecalculation: true,
                }, function () {
                    if (_this.isUnmounted) {
                        return;
                    }
                    _this.recalculationTick = reactViewportUtils.requestAnimationFrame(function () {
                        _this.setState({
                            isRecalculating: false,
                        });
                        _this.recalculationTick = undefined;
                    });
                });
                return;
            }
            if (stickyRect) {
                if (_this.state.isWaitingForRecalculation ||
                    stickyRect.height !== _this.state.stickyHeight ||
                    stickyRect.width !== _this.state.stickyWidth) {
                    _this.setState({
                        clientHash: nextClientHash,
                        stickyHeight: stickyRect.height,
                        stickyWidth: stickyRect.width,
                        isWaitingForRecalculation: false,
                    });
                    return;
                }
            }
        };
        _this.handleElementResize = function (stickyRect) {
            if (_this.lastDimensions) {
                _this.handleDimensionsUpdate({ dimensions: _this.lastDimensions }, stickyRect);
            }
        };
        return _this;
    }
    StickyPlaceholder.prototype.componentWillUnmount = function () {
        reactViewportUtils.cancelAnimationFrame(this.recalculationTick);
        this.isUnmounted = true;
    };
    StickyPlaceholder.prototype.render = function () {
        var _a = this.props, children = _a.children, disabled = _a.disabled, style = _a.style, className = _a.className, forwardRef = _a.forwardRef;
        var _b = this.state, isRecalculating = _b.isRecalculating, isWaitingForRecalculation = _b.isWaitingForRecalculation, stickyHeight = _b.stickyHeight, stickyWidth = _b.stickyWidth;
        var isActive = !disabled && !isWaitingForRecalculation;
        var baseStyle = __assign({ position: 'relative' }, style);
        var containerStyle = isActive
            ? __assign({ height: stickyHeight, width: stickyWidth }, baseStyle)
            : baseStyle;
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { ref: forwardRef, style: containerStyle, className: className }, children({
                isRecalculating: isWaitingForRecalculation,
            })),
            !this.props.disableResizing && (React.createElement(React.Fragment, null,
                React.createElement(reactViewportUtils.ObserveViewport, { disableScrollUpdates: true, disableDimensionsUpdates: isRecalculating, onUpdate: this.handleDimensionsUpdate, recalculateLayoutBeforeUpdate: this.calculateSize, priority: "highest" }),
                React.createElement(ElementResizeObserver, { stickyRef: this.props.stickyRef, onUpdate: this.handleElementResize })))));
    };
    StickyPlaceholder.defaultProps = {
        style: {},
    };
    return StickyPlaceholder;
}(React.Component));

var supportsWillChange = (function () {
    var isBrowser = typeof window !== 'undefined' &&
        typeof document !== 'undefined' &&
        document.documentElement;
    if (!isBrowser) {
        return false;
    }
    return 'willChange' in document.documentElement.style;
})();
var supportsPositionSticky = (function () {
    var isBrowser = typeof window !== 'undefined' && typeof CSS !== 'undefined';
    if (!isBrowser) {
        return false;
    }
    return CSS.supports ? CSS.supports('position: sticky') : false;
})();
var shallowEqualPositionStyles = function (a, b) {
    if (a === b) {
        return true;
    }
    if (a.position !== b.position) {
        return false;
    }
    if (a.top !== b.top) {
        return false;
    }
    if (a.transform !== b.transform) {
        return false;
    }
    if (a.willChange !== b.willChange) {
        return false;
    }
    return true;
};

var Sticky = /** @class */ (function (_super) {
    __extends(Sticky, _super);
    function Sticky() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stickyRef = React.createRef();
        _this.placeholderRef = React.createRef();
        _this.nativeStickyThrewOnce = false;
        _this.state = {
            isSticky: false,
            isDockedToBottom: false,
            isNearToViewport: false,
            appliedOverflowScroll: 'end',
            styles: {},
            useNativeSticky: false,
        };
        _this.hasContainer = function () {
            return Boolean(_this.props.container);
        };
        _this.isNearToViewport = function (rect) {
            var padding = 700;
            return rect.top - padding < 0 && rect.bottom + padding > 0;
        };
        _this.getOverflowScrollType = function (rectSticky, dimensions) {
            return _this.props.overflowScroll === 'flow' &&
                _this.calcHeightDifference(rectSticky, dimensions) > 0
                ? 'flow'
                : 'end';
        };
        _this.isSticky = function (rect, containerRect, dimensions) {
            if (!_this.hasContainer()) {
                return Math.round(containerRect.top) <= _this.offsetTop;
            }
            if (Math.round(containerRect.top) > _this.offsetTop) {
                return false;
            }
            var height = _this.props.overflowScroll === 'flow'
                ? Math.min(rect.height, dimensions.height)
                : rect.height;
            if (Math.round(containerRect.bottom) - _this.offsetTop < height) {
                return false;
            }
            return true;
        };
        _this.shouldUseNativeSticky = function (appliedOverflowScroll) {
            if (!_this.props.experimentalNative ||
                !supportsPositionSticky ||
                appliedOverflowScroll !== 'end' ||
                _this.props.stickyOffset.top !== 0) {
                return false;
            }
            if (process.env.NODE_ENV !== 'production' &&
                !_this.nativeStickyThrewOnce &&
                (_this.placeholderRef && _this.placeholderRef.current.parentElement) !==
                    (_this.props.container && _this.props.container.current)) {
                console.warn('react-stickup: a sticky element was used with property `experimentalNative` but its `container` is not the parent the sticky component. As the native sticky implementation always uses its parent element as the container. This can lead to unexpected results. It is therefore recommended to change the DOM structure so that the container is a direct parent of the Sticky component or to remove the `experimentalNative` property.');
                _this.nativeStickyThrewOnce = true;
            }
            return true;
        };
        _this.isDockedToBottom = function (rect, containerRect, dimensions) {
            if (!rect || !containerRect) {
                return false;
            }
            if (!_this.hasContainer()) {
                return false;
            }
            if (rect.height > containerRect.height) {
                return false;
            }
            var height = _this.props.overflowScroll === 'flow'
                ? Math.min(rect.height, dimensions.height)
                : rect.height;
            if (Math.round(containerRect.bottom) - _this.offsetTop >= height) {
                return false;
            }
            return true;
        };
        _this.recalculateLayoutBeforeUpdate = function () {
            var containerRect = _this.container.current.getBoundingClientRect();
            var stickyRect = _this.stickyRef.current.getBoundingClientRect();
            return {
                stickyRect: stickyRect,
                containerRect: containerRect,
            };
        };
        _this.handleScrollUpdate = function (_a, _b) {
            var scroll = _a.scroll, dimensions = _a.dimensions;
            var stickyRect = _b.stickyRect, containerRect = _b.containerRect;
            if (_this.props.disabled) {
                return;
            }
            // in case children is not a function renderArgs will never be used
            var willRenderAsAFunction = typeof _this.props.children === 'function';
            var appliedOverflowScroll = _this.getOverflowScrollType(stickyRect, dimensions);
            var useNativeSticky = _this.shouldUseNativeSticky(appliedOverflowScroll);
            var styles = useNativeSticky
                ? {}
                : _this.getStickyStyles(stickyRect, containerRect, scroll, dimensions);
            var stateStyles = _this.state.styles;
            var stylesDidChange = !shallowEqualPositionStyles(styles, stateStyles);
            var isSticky = willRenderAsAFunction
                ? _this.isSticky(stickyRect, containerRect, dimensions)
                : false;
            var isDockedToBottom = willRenderAsAFunction
                ? _this.isDockedToBottom(stickyRect, containerRect, dimensions)
                : false;
            var isNearToViewport = _this.isNearToViewport(stickyRect);
            var useNativeStickyDidChange = _this.state.useNativeSticky !== useNativeSticky;
            var isStickyDidChange = _this.state.isSticky !== isSticky;
            var isDockedToBottomDidChange = _this.state.isDockedToBottom !== isDockedToBottom;
            var isNearToViewportDidChange = _this.state.isNearToViewport !== isNearToViewport;
            var appliedOverflowScrollDidChange = appliedOverflowScroll !== _this.state.appliedOverflowScroll;
            if (!useNativeStickyDidChange &&
                !stylesDidChange &&
                !isStickyDidChange &&
                !isDockedToBottomDidChange &&
                !isNearToViewportDidChange &&
                !appliedOverflowScrollDidChange) {
                return;
            }
            _this.setState({
                useNativeSticky: useNativeSticky,
                isSticky: isSticky,
                isDockedToBottom: isDockedToBottom,
                isNearToViewport: isNearToViewport,
                appliedOverflowScroll: appliedOverflowScroll,
                styles: stylesDidChange ? styles : stateStyles,
            });
        };
        _this.renderSticky = function (_a) {
            var isRecalculating = _a.isRecalculating;
            var _b = _this.props, children = _b.children, disabled = _b.disabled, stickyProps = _b.stickyProps;
            return (React.createElement(StickyElement, __assign({ forwardRef: _this.stickyRef, positionStyle: _this.state.styles, disabled: disabled || isRecalculating, children: children, renderArgs: {
                    isSticky: _this.state.isSticky,
                    isDockedToBottom: _this.state.isDockedToBottom,
                    isNearToViewport: _this.state.isNearToViewport,
                    appliedOverflowScroll: _this.state.appliedOverflowScroll,
                } }, stickyProps)));
        };
        return _this;
    }
    Object.defineProperty(Sticky.prototype, "container", {
        get: function () {
            return this.props.container || this.placeholderRef;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sticky.prototype, "offsetTop", {
        get: function () {
            return this.props.stickyOffset.top + this.props.defaultOffsetTop;
        },
        enumerable: false,
        configurable: true
    });
    Sticky.prototype.calcHeightDifference = function (rectSticky, dimensions) {
        if (!dimensions) {
            return 0;
        }
        return Math.max(0, Math.round(rectSticky.height) - dimensions.height);
    };
    Sticky.prototype.calcOverflowScrollFlowStickyStyles = function (rectSticky, containerRect, scroll, dimensions) {
        var containerTop = Math.round(containerRect.top);
        var stickyTop = Math.round(rectSticky.top);
        var scrollY = Math.round(scroll.y);
        var scrollYTurn = Math.round(scroll.yTurn);
        var heightDiff = this.calcHeightDifference(rectSticky, dimensions);
        var containerTopOffset = containerTop + scrollY - this.props.stickyOffset.height;
        var isStickyBottomReached = Math.round(rectSticky.bottom) <= dimensions.height;
        var isContainerTopReached = containerTop < this.offsetTop;
        var isTurnWithinHeightOffset = scrollYTurn - heightDiff <= containerTopOffset;
        var isTurnPointBeforeContainer = scrollYTurn < containerTopOffset;
        var isTurnPointAfterContainer = scrollYTurn > containerTopOffset + containerRect.height;
        var isTurnPointWithinContainer = !(isTurnPointBeforeContainer || isTurnPointAfterContainer);
        // scroll down AND sticky rect bottom not reached AND turn point not within the container OR
        // scroll up AND container top not reached OR
        //scroll up AND turns within the height diff AND turn point not within the container
        if ((scroll.isScrollingDown &&
            !isStickyBottomReached &&
            !isTurnPointWithinContainer) ||
            (scroll.isScrollingUp && !isContainerTopReached) ||
            (scroll.isScrollingUp &&
                isTurnWithinHeightOffset &&
                !isTurnPointWithinContainer)) {
            return {
                position: 'absolute',
                top: 0,
            };
        }
        // scroll down AND sticky bottom reached
        if (scroll.isScrollingDown && isStickyBottomReached) {
            return {
                position: 'fixed',
                top: -heightDiff,
            };
        }
        var isStickyTopReached = stickyTop >= this.offsetTop;
        // scroll down AND turn point within container OR
        // scroll up AND turn point not before container AND not sticky top reached
        if ((scroll.isScrollingDown && isTurnPointWithinContainer) ||
            (scroll.isScrollingUp &&
                !isTurnPointBeforeContainer &&
                !isStickyTopReached)) {
            return {
                position: 'absolute',
                top: Math.abs(scrollY - stickyTop + (containerTop - scrollY)),
            };
        }
        return {
            position: 'fixed',
            top: this.offsetTop,
        };
    };
    Sticky.prototype.calcPositionStyles = function (rectSticky, containerRect, scroll, dimensions) {
        if (this.isSticky(rectSticky, containerRect, dimensions)) {
            if (this.getOverflowScrollType(rectSticky, dimensions) === 'flow') {
                return this.calcOverflowScrollFlowStickyStyles(rectSticky, containerRect, scroll, dimensions);
            }
            var stickyOffset = this.props.stickyOffset.top;
            var stickyHeight = this.props.stickyOffset.height;
            var headIsFlexible = stickyOffset > 0 && stickyOffset < stickyHeight;
            if (headIsFlexible) {
                var relYTurn = Math.round(scroll.yTurn - scroll.y + scroll.yDTurn) -
                    Math.round(containerRect.top);
                return {
                    position: 'absolute',
                    top: relYTurn + this.offsetTop,
                };
            }
            return {
                position: 'fixed',
                top: this.offsetTop,
            };
        }
        if (this.isDockedToBottom(rectSticky, containerRect, dimensions)) {
            return {
                position: 'absolute',
                top: containerRect.height - rectSticky.height,
            };
        }
        return {
            position: 'absolute',
            top: 0,
        };
    };
    Sticky.prototype.getStickyStyles = function (rect, containerRect, scroll, dimensions) {
        var styles = this.calcPositionStyles(rect, containerRect, scroll, dimensions);
        if (!this.props.disableHardwareAcceleration) {
            var shouldAccelerate = this.isNearToViewport(rect);
            if (supportsWillChange) {
                styles.willChange = shouldAccelerate ? 'position, top' : null;
            }
            else {
                styles.transform = shouldAccelerate ? "translateZ(0)" : null;
            }
        }
        return styles;
    };
    Sticky.prototype.render = function () {
        var _a = this.props, disabled = _a.disabled, disableResizing = _a.disableResizing, style = _a.style, className = _a.className, overflowScroll = _a.overflowScroll;
        return (React.createElement(React.Fragment, null,
            React.createElement(StickyPlaceholder, { className: className, style: this.state.useNativeSticky
                    ? __assign({ position: 'sticky', top: this.props.defaultOffsetTop }, style) : style, disabled: disabled, forwardRef: this.placeholderRef, stickyRef: this.stickyRef, disableResizing: disableResizing }, this.renderSticky),
            React.createElement(reactViewportUtils.ObserveViewport, { disableScrollUpdates: disabled, disableDimensionsUpdates: disabled || overflowScroll !== 'flow', onUpdate: this.handleScrollUpdate, recalculateLayoutBeforeUpdate: this.recalculateLayoutBeforeUpdate, priority: this.state.isNearToViewport ? 'highest' : 'low' })));
    };
    Sticky.defaultProps = {
        stickyOffset: { top: 0, height: 0 },
        defaultOffsetTop: 0,
        disableResizing: false,
        disableHardwareAcceleration: false,
        overflowScroll: 'end',
        experimentalNative: false,
        style: {},
    };
    return Sticky;
}(React.PureComponent));
var Sticky$1 = connect()(Sticky);

var calcPositionStyles = function (rect, scroll, _a) {
    var _b = _a.offsetTop, offsetTop = _b === void 0 ? 0 : _b;
    var rectTop = Math.round(rect.top);
    var scrollY = Math.round(scroll.y);
    if (scroll.isScrollingDown) {
        // disable sticky mode above the top offset while scrolling down
        if (rectTop > 0 && scrollY < offsetTop) {
            return {
                position: 'absolute',
                top: 0,
            };
        }
        // element is visible and scrolls down
        return {
            position: 'absolute',
            top: Math.max(scrollY - offsetTop + rectTop, 0),
        };
    }
    var isTopVisible = rectTop >= 0;
    var isBottomVisible = rectTop + rect.height <= 0;
    // element is visible and scrolls up
    if (!isTopVisible && !isBottomVisible) {
        return {
            position: 'absolute',
            top: scrollY - offsetTop + rectTop,
        };
    }
    // disable sticky mode above the top offset while scrolling up
    if (scrollY <= offsetTop) {
        return {
            position: 'absolute',
            top: 0,
        };
    }
    if (Math.round(scroll.yDTurn) === 0) {
        // scroll direction changed from down to up and the element was not visible
        if (isBottomVisible) {
            return {
                position: 'absolute',
                top: Math.round(scroll.yTurn) - offsetTop - rect.height,
            };
        }
        // scroll direction changed from down to up and the element was fully visible
        return {
            position: 'absolute',
            top: Math.max(scrollY - offsetTop, 0),
        };
    }
    // set sticky
    return {
        position: 'fixed',
        top: 0,
    };
};
var StickyScrollUp = /** @class */ (function (_super) {
    __extends(StickyScrollUp, _super);
    function StickyScrollUp() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stickyRef = React.createRef();
        _this.placeholderRef = React.createRef();
        _this.stickyOffset = null;
        _this.stickyOffsetHeight = 0;
        _this.state = {
            styles: {},
            isNearToViewport: false,
            isSticky: false,
        };
        _this.isNearToViewport = function (rect) {
            var padding = 700;
            return rect.top - padding < 0;
        };
        _this.recalculateLayoutBeforeUpdate = function () {
            return {
                placeholderRect: _this.placeholderRef.current.getBoundingClientRect(),
                stickyRect: _this.stickyRef.current.getBoundingClientRect(),
            };
        };
        _this.handleViewportUpdate = function (_a, _b) {
            var scroll = _a.scroll;
            var stickyRect = _b.stickyRect, placeholderRect = _b.placeholderRect;
            if (_this.props.disabled) {
                return;
            }
            // in case children is not a function renderArgs will never be used
            var willRenderAsAFunction = typeof _this.props.children === 'function';
            var nextOffset = Math.max(Math.round(stickyRect.bottom), 0);
            var nextOffsetHeight = stickyRect.height;
            var offsetDidChange = _this.stickyOffset !== nextOffset;
            var offsetHeightDidChange = _this.stickyOffsetHeight !== nextOffsetHeight;
            var styles = _this.getStickyStyles(stickyRect, placeholderRect, scroll);
            var stateStyles = _this.state.styles;
            var stylesDidChange = !shallowEqualPositionStyles(styles, stateStyles);
            var isNearToViewport = _this.isNearToViewport(stickyRect);
            var isSticky = willRenderAsAFunction
                ? styles.top === 0 && styles.position === 'fixed'
                : false;
            var isNearToViewportDidChange = _this.state.isNearToViewport !== isNearToViewport;
            var isStickyDidChange = _this.state.isSticky !== isSticky;
            if (_this.props.updateStickyOffset &&
                (offsetDidChange || offsetHeightDidChange)) {
                _this.props.updateStickyOffset(nextOffset, nextOffsetHeight);
            }
            if (!stylesDidChange && !isNearToViewportDidChange && !isStickyDidChange) {
                return;
            }
            _this.setState({
                styles: stylesDidChange ? styles : stateStyles,
                isNearToViewport: isNearToViewport,
                isSticky: isSticky,
            });
        };
        _this.renderSticky = function (_a) {
            var isRecalculating = _a.isRecalculating;
            var _b = _this.props, disabled = _b.disabled, children = _b.children, stickyProps = _b.stickyProps;
            return (React.createElement(StickyElement, __assign({ forwardRef: _this.stickyRef, positionStyle: _this.state.styles, disabled: disabled || isRecalculating, children: children, renderArgs: {
                    isNearToViewport: _this.state.isNearToViewport,
                    isSticky: _this.state.isSticky,
                } }, stickyProps)));
        };
        return _this;
    }
    StickyScrollUp.prototype.componentDidUpdate = function (prevProps, prevState) {
        if (this.props.updateStickyOffset &&
            prevProps.disabled !== this.props.disabled) {
            this.props.updateStickyOffset(this.props.disabled ? 0 : this.stickyOffset, this.stickyOffsetHeight);
        }
    };
    StickyScrollUp.prototype.getStickyStyles = function (stickyRect, placeholderRect, scroll) {
        var offsetTop = isNaN(this.props.defaultOffsetTop)
            ? Math.round(placeholderRect.top) + Math.round(scroll.y)
            : this.props.defaultOffsetTop;
        var styles = calcPositionStyles(stickyRect, scroll, {
            offsetTop: offsetTop,
        });
        if (!this.props.disableHardwareAcceleration) {
            var shouldAccelerate = this.isNearToViewport(stickyRect);
            if (supportsWillChange) {
                styles.willChange = shouldAccelerate ? 'position, top' : null;
            }
            else {
                styles.transform = shouldAccelerate ? "translateZ(0)" : null;
            }
        }
        return styles;
    };
    StickyScrollUp.prototype.render = function () {
        var _a = this.props, disabled = _a.disabled, disableResizing = _a.disableResizing, style = _a.style, className = _a.className;
        return (React.createElement(React.Fragment, null,
            React.createElement(StickyPlaceholder, { className: className, style: style, disabled: disabled, stickyRef: this.stickyRef, disableResizing: disableResizing, forwardRef: this.placeholderRef }, this.renderSticky),
            React.createElement(reactViewportUtils.ObserveViewport, { disableScrollUpdates: disabled, disableDimensionsUpdates: true, onUpdate: this.handleViewportUpdate, recalculateLayoutBeforeUpdate: this.recalculateLayoutBeforeUpdate, priority: this.state.isNearToViewport ? 'highest' : 'low' })));
    };
    StickyScrollUp.defaultProps = {
        disableHardwareAcceleration: false,
        disableResizing: false,
        style: {},
    };
    return StickyScrollUp;
}(React.PureComponent));
var StickyScrollUp$1 = connect()(StickyScrollUp);

exports.Sticky = Sticky$1;
exports.StickyProvider = StickyScrollUpProvider;
exports.StickyScrollUp = StickyScrollUp$1;
//# sourceMappingURL=index.js.map
