import { useState, useCallback, useEffect, useRef, useMemo, createRef } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var debounce = function (callback, wait) {
    var timeoutId;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function () {
            callback.apply(null, args);
        }, wait);
    };
};

var DEFAULT_DELAY = 150;
var useSizeDetector = function (_a) {
    var root = _a.root, isHorizontal = _a.isHorizontal, activeId = _a.activeId, onChange = _a.onChange, setForceRecompute = _a.setForceRecompute, updateActiveId = _a.updateActiveId, hasWindow = _a.hasWindow;
    var _b = useState(1), targetSize = _b[0], setTargetSize = _b[1];
    var useViewport = root == null ||
        (hasWindow &&
            (isHorizontal
                ? window.innerWidth < root.clientWidth
                : window.innerHeight < root.clientHeight));
    var scrollEnd = useCallback(debounce(function () {
        setForceRecompute(true);
    }, DEFAULT_DELAY), [setForceRecompute]);
    useEffect(function () {
        if (!hasWindow) {
            return;
        }
        var observer = null;
        var resizeWindowHandler = function () {
            setTimeout(function () {
                setTargetSize(isHorizontal ? window.innerWidth : window.innerHeight);
            }, DEFAULT_DELAY);
        };
        var resizeElementHandler = function (entries) {
            var entry = entries[0];
            if (!useViewport) {
                setTargetSize(isHorizontal
                    ? entry.boundingClientRect.width
                    : entry.boundingClientRect.height);
            }
            if (entry.intersectionRatio === 0) {
                if (activeId != null) {
                    updateActiveId(null);
                    if (onChange) {
                        onChange({
                            added: null,
                            removed: activeId
                        });
                    }
                }
            }
        };
        addEventListener('scroll', scrollEnd);
        if (useViewport) {
            setTargetSize(isHorizontal ? window.innerWidth : window.innerHeight);
            addEventListener('resize', resizeWindowHandler);
        }
        if (root) {
            observer = new IntersectionObserver(resizeElementHandler);
            observer.observe(root);
        }
        return function () {
            if (observer) {
                observer.disconnect();
            }
            removeEventListener('resize', resizeWindowHandler);
            removeEventListener('scroll', scrollEnd);
        };
    }, [root, isHorizontal, activeId, onChange, useViewport, scrollEnd]);
    return { targetSize: targetSize, useViewport: useViewport };
};

var hasWindow = typeof window !== 'undefined';
var REGISTER_DELAY = 50;
function resolveHierarchyIds(id, lookup) {
    var newActiveIds = [id];
    var lastId = newActiveIds[0];
    while (lastId != null && lookup[lastId] != null) {
        newActiveIds.push(lookup[lastId]);
        lastId = lookup[lastId];
    }
    // return a list from parent to current child
    return newActiveIds.reverse();
}
/**
 * This is the main hook: use it in a react function component to track
 * the state of the passed ids. The function accepts an initial configuration
 * of type `useNavScrollArgs` to customize the behaviour.
 */
function useNavScroll(args) {
    if (args === void 0) { args = {}; }
    var onChange = args.onChange, root = args.root, _a = args.offset, offset = _a === void 0 ? 50 : _a, _b = args.isHorizontal, isHorizontal = _b === void 0 ? false : _b;
    var els = useRef([]);
    var _c = useState(0), counter = _c[0], setCounter = _c[1];
    var _d = useState(false), forceRecompute = _d[0], setForceRecompute = _d[1];
    var _e = useState(null), activeId = _e[0], updateActiveId = _e[1];
    var _f = useSizeDetector({
        root: root,
        isHorizontal: isHorizontal,
        onChange: onChange,
        activeId: activeId,
        setForceRecompute: setForceRecompute,
        updateActiveId: updateActiveId,
        hasWindow: hasWindow
    }), targetSize = _f.targetSize, useViewport = _f.useViewport;
    var observerMargin = Math.floor((targetSize * offset) / 100) || 1;
    var observerOptions = useMemo(function () {
        var topMargin = observerMargin % 2 === 1 ? observerMargin - 1 : observerMargin;
        var bottomMargin = targetSize - observerMargin;
        return {
            root: useViewport ? null : root,
            rootMargin: isHorizontal
                ? "0px " + -topMargin + "px 0px " + -bottomMargin + "px"
                : -topMargin + "px 0px " + -bottomMargin + "px 0px"
        };
    }, [root, targetSize, observerMargin, isHorizontal, useViewport]);
    var elsLookup = useMemo(function () {
        var lookup = {};
        for (var _i = 0, _a = els.current; _i < _a.length; _i++) {
            var _b = _a[_i], id = _b.id, parent_1 = _b.parent;
            lookup[id] = parent_1;
        }
        return lookup;
    }, [counter]);
    var activeIds = useMemo(function () { return (activeId ? resolveHierarchyIds(activeId, elsLookup) : []); }, [activeId, elsLookup]);
    var activeLookups = useMemo(function () { return new Set(activeIds); }, [activeIds]);
    useEffect(function () {
        if (!hasWindow) {
            return;
        }
        var handleIntersection = function (entries) {
            var intersectionId = null;
            var topMin = Infinity;
            entries.forEach(function (entry) {
                if (entry.isIntersecting) {
                    if (topMin > entry.boundingClientRect.top) {
                        topMin = entry.boundingClientRect.top;
                        intersectionId = entry.target.id;
                    }
                }
            });
            if (intersectionId != null) {
                updateActiveId(intersectionId);
                if (onChange) {
                    var diffIds = {
                        added: intersectionId,
                        removed: activeId
                    };
                    onChange(diffIds);
                }
            }
        };
        var observer = new IntersectionObserver(handleIntersection, observerOptions);
        els.current.forEach(function (_a) {
            var ref = _a.ref;
            if (ref && ref.current) {
                observer.observe(ref.current);
            }
        });
        if (forceRecompute) {
            handleIntersection(observer.takeRecords());
            setForceRecompute(false);
        }
        return function () {
            observer.disconnect();
        };
    }, [
        activeIds,
        updateActiveId,
        els,
        elsLookup,
        onChange,
        activeLookups,
        activeId,
        observerOptions,
        isHorizontal,
        root,
        forceRecompute
    ]);
    var refresh = useCallback(debounce(function () {
        setCounter(counter + 1);
    }, REGISTER_DELAY), [counter]);
    var register = useCallback(function (id, options) {
        if (options === void 0) { options = {}; }
        if (!hasWindow) {
            return { id: id, ref: null };
        }
        var alreadyRegistered = id in elsLookup;
        var entry = alreadyRegistered
            ? els.current.find(function (_a) {
                var existingId = _a.id;
                return existingId === id;
            })
            : options;
        var ref = (entry && entry.ref) || createRef();
        if (!alreadyRegistered) {
            els.current = __spreadArrays(els.current, [{ id: id, ref: ref, parent: options.parent }]);
            refresh();
        }
        return { id: id, ref: ref };
    }, [counter]);
    var unregister = useCallback(function (idToUnregister) {
        els.current = els.current.filter(function (_a) {
            var id = _a.id;
            return id !== idToUnregister;
        });
    }, [counter]);
    var isActive = useCallback(function (id) { return activeLookups.has(id); }, [activeLookups]);
    var getActiveRef = useCallback(function () {
        var entry = els.current.find(function (_a) {
            var id = _a.id;
            return id === activeId;
        });
        return entry ? entry.ref : null;
    }, [activeId]);
    return {
        register: register,
        unregister: unregister,
        activeIds: activeIds,
        isActive: isActive,
        getActiveRef: getActiveRef
    };
}

export { useNavScroll };
//# sourceMappingURL=index.es.js.map
