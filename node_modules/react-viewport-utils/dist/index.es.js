import { PureComponent, createContext, createRef, createElement, Fragment, Component, useContext, useEffect, useState, useRef } from 'react';
import memoize from 'memoize-one';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var shallowEqualScroll = function (a, b) {
    if (a === b) {
        return true;
    }
    return (a.x === b.x &&
        a.y === b.y &&
        a.xTurn === b.xTurn &&
        a.yTurn === b.yTurn &&
        a.xDTurn === b.xDTurn &&
        a.yDTurn === b.yDTurn &&
        a.isScrollingUp === b.isScrollingUp &&
        a.isScrollingDown === b.isScrollingDown &&
        a.isScrollingLeft === b.isScrollingLeft &&
        a.isScrollingRight === b.isScrollingRight);
};
var shallowEqualRect = function (a, b) {
    if (a === b) {
        return true;
    }
    return (a.top === b.top &&
        a.right === b.right &&
        a.bottom === b.bottom &&
        a.left === b.left &&
        a.height === b.height &&
        a.width === b.width);
};
var shallowEqualDimensions = function (a, b) {
    if (a === b) {
        return true;
    }
    return (a.width === b.width &&
        a.height === b.height &&
        a.clientWidth === b.clientWidth &&
        a.clientHeight === b.clientHeight &&
        a.outerWidth === b.outerWidth &&
        a.outerHeight === b.outerHeight &&
        a.documentWidth === b.documentWidth &&
        a.documentHeight === b.documentHeight);
};
// implementation based on https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
var browserSupportsPassiveEvents = (function () {
    if (typeof window === 'undefined') {
        return false;
    }
    var supportsPassive = false;
    try {
        var opts = Object.defineProperty({}, 'passive', {
            get: function () {
                supportsPassive = true;
            },
        });
        window.addEventListener('testPassive', null, opts);
        window.removeEventListener('testPassive', null, opts);
    }
    catch (e) {
        return false;
    }
    return supportsPassive;
})();
var simpleDebounce = function (fn, delay) {
    var timeout;
    return (function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        clearTimeout(timeout);
        timeout = setTimeout.apply(void 0, __spreadArrays([fn, delay], args));
    });
};
var debounceOnUpdate = function (fn, delay) {
    var timeout;
    var scrollDidUpdate = false;
    var dimensionsDidUpdate = false;
    return function (viewport, options) {
        clearTimeout(timeout);
        scrollDidUpdate = scrollDidUpdate || options.scrollDidUpdate;
        dimensionsDidUpdate = dimensionsDidUpdate || options.dimensionsDidUpdate;
        timeout = setTimeout(function () {
            fn(viewport, {
                scrollDidUpdate: scrollDidUpdate,
                dimensionsDidUpdate: dimensionsDidUpdate,
            });
            scrollDidUpdate = false;
            dimensionsDidUpdate = false;
        }, delay);
    };
};
var warnNoContextAvailable = function (location) {
    if (process.env.NODE_ENV === 'production') {
        return;
    }
    var fromHook = location.startsWith('use');
    if (fromHook) {
        console.warn("react-viewport-utils: " + location + " hook is not able to connect to a <ViewportProvider>. Therefore it cannot detect updates from the viewport and will not work as expected. To resolve this issue please add a <ViewportProvider> as a parent of the component using the hook, e.g. directly in the ReactDOM.render call:\n\nimport * as ReactDOM from 'react-dom';\nimport { ViewportProvider, " + location + " } from 'react-viewport-utils';\n\nconst MyComponent = () => {\n  " + location + "()\n  ...\n}\n\nReactDOM.render(\n  <ViewportProvider>\n    <main role=\"main\">\n      <MyComponent />\n    </main>\n  </ViewportProvider>,\n  document.getElementById('root')\n);");
        return;
    }
    console.warn("react-viewport-utils: " + location + " component is not able to connect to a <ViewportProvider>. Therefore it cannot detect updates from the viewport and will not work as expected. To resolve this issue please add a <ViewportProvider> as a parent of the <ObserveViewport> component, e.g. directly in the ReactDOM.render call:\n\nimport * as ReactDOM from 'react-dom';\nimport { ViewportProvider, ObserveViewport } from 'react-viewport-utils';\nReactDOM.render(\n  <ViewportProvider>\n    <main role=\"main\">\n      <ObserveViewport>\n        {({ scroll, dimensions }) => ...}\n      </ObserveViewport>\n    </main>\n  </ViewportProvider>,\n  document.getElementById('root')\n);");
};
var warnNoResizeObserver = function () {
    if (process.env.NODE_ENV === 'production') {
        return;
    }
    console.warn('react-viewport-utils: This browser does not support the ResizeObserver API, therefore not all possible resize events will be detected. In most of the cases this is not an issue and can be ignored. If its relevant to your application please consider adding a polyfill, e.g. https://www.npmjs.com/package/resize-observer-polyfill .');
};
var requestAnimationFrame = (function () {
    if (typeof window !== 'undefined') {
        var nativeRAF = window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame;
        if (nativeRAF) {
            return nativeRAF.bind(window);
        }
    }
    return function requestAnimationFrameFallback(callback) {
        return setTimeout(callback, 1000 / 60);
    };
})();
var cancelAnimationFrame = (function () {
    if (typeof window !== 'undefined') {
        var nativeCAF = window.cancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.webkitCancelRequestAnimationFrame;
        if (nativeCAF) {
            return nativeCAF.bind(window);
        }
    }
    return clearTimeout;
})();
var now = typeof performance !== 'undefined' && performance.now
    ? performance.now.bind(performance)
    : Date.now.bind(Date);
var createPerformanceMarker = function () {
    var start = now();
    return function () { return now() - start; };
};

var getClientDimensions = function () {
    if (typeof document === 'undefined' || !document.documentElement) {
        return createEmptyDimensionState();
    }
    var innerWidth = window.innerWidth, innerHeight = window.innerHeight, outerWidth = window.outerWidth, outerHeight = window.outerHeight;
    var _a = document.documentElement, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight, scrollHeight = _a.scrollHeight, scrollWidth = _a.scrollWidth, offsetHeight = _a.offsetHeight, offsetWidth = _a.offsetWidth;
    return {
        width: innerWidth,
        height: innerHeight,
        clientWidth: clientWidth,
        clientHeight: clientHeight,
        outerWidth: outerWidth,
        outerHeight: outerHeight,
        documentWidth: Math.max(scrollWidth, offsetWidth, clientWidth),
        documentHeight: Math.max(scrollHeight, offsetHeight, clientHeight),
    };
};
var getNodeScroll = function (elem) {
    if (elem === void 0) { elem = window; }
    var scrollX = elem.scrollX, scrollY = elem.scrollY;
    if (scrollX === undefined) {
        scrollX = elem.pageXOffset;
    }
    if (scrollY === undefined) {
        scrollY = elem.pageYOffset;
    }
    return {
        x: scrollX,
        y: scrollY,
    };
};
var getClientScroll = function (prevScrollState) {
    if (prevScrollState === void 0) { prevScrollState = createEmptyScrollState(); }
    if (typeof window === 'undefined') {
        return createEmptyScrollState();
    }
    var _a = getNodeScroll(), x = _a.x, y = _a.y;
    var nextScrollState = __assign({}, prevScrollState);
    var prevIsScrollingLeft = prevScrollState.isScrollingLeft, prevIsScrollingUp = prevScrollState.isScrollingUp, prevXTurn = prevScrollState.xTurn, prevYTurn = prevScrollState.yTurn;
    nextScrollState.isScrollingLeft = isScrollingLeft(x, nextScrollState);
    nextScrollState.isScrollingRight = isScrollingRight(x, nextScrollState);
    nextScrollState.isScrollingUp = isScrollingUp(y, nextScrollState);
    nextScrollState.isScrollingDown = isScrollingDown(y, nextScrollState);
    nextScrollState.xTurn =
        nextScrollState.isScrollingLeft === prevIsScrollingLeft ? prevXTurn : x;
    nextScrollState.yTurn =
        nextScrollState.isScrollingUp === prevIsScrollingUp ? prevYTurn : y;
    nextScrollState.xDTurn = x - nextScrollState.xTurn;
    nextScrollState.yDTurn = y - nextScrollState.yTurn;
    nextScrollState.x = x;
    nextScrollState.y = y;
    return nextScrollState;
};
var isScrollingLeft = function (x, prev) {
    switch (true) {
        case x < prev.x:
            return true;
        case x > prev.x:
            return false;
        case x === prev.x:
            return prev.isScrollingLeft;
        default:
            throw new Error('Could not calculate isScrollingLeft');
    }
};
var isScrollingRight = function (x, prev) {
    switch (true) {
        case x > prev.x:
            return true;
        case x < prev.x:
            return false;
        case x === prev.x:
            return prev.isScrollingRight;
        default:
            throw new Error('Could not calculate isScrollingRight');
    }
};
var isScrollingUp = function (y, prev) {
    switch (true) {
        case y < prev.y:
            return true;
        case y > prev.y:
            return false;
        case y === prev.y:
            return prev.isScrollingUp;
        default:
            throw new Error('Could not calculate isScrollingUp');
    }
};
var isScrollingDown = function (y, prev) {
    switch (true) {
        case y > prev.y:
            return true;
        case y < prev.y:
            return false;
        case y === prev.y:
            return prev.isScrollingDown;
        default:
            throw new Error('Could not calculate isScrollingDown');
    }
};
var createEmptyScrollState = function () { return ({
    x: 0,
    y: 0,
    isScrollingUp: false,
    isScrollingDown: false,
    isScrollingLeft: false,
    isScrollingRight: false,
    xTurn: 0,
    yTurn: 0,
    xDTurn: 0,
    yDTurn: 0,
}); };
var createEmptyDimensionState = function () { return ({
    width: 0,
    height: 0,
    clientWidth: 0,
    clientHeight: 0,
    outerWidth: 0,
    outerHeight: 0,
    documentWidth: 0,
    documentHeight: 0,
}); };
var ViewportCollector = /** @class */ (function (_super) {
    __extends(ViewportCollector, _super);
    function ViewportCollector(props) {
        var _this = _super.call(this, props) || this;
        _this.tick = function () {
            if (_this) {
                if (_this.scrollMightHaveUpdated || _this.resizeMightHaveUpdated) {
                    _this.syncState();
                    _this.scrollMightHaveUpdated = false;
                    _this.resizeMightHaveUpdated = false;
                }
                _this.tickId = undefined;
            }
        };
        _this.handleScroll = function () {
            _this.scrollMightHaveUpdated = true;
            if (!_this.tickId) {
                _this.tickId = requestAnimationFrame(_this.tick);
            }
        };
        _this.handleResize = function () {
            _this.resizeMightHaveUpdated = true;
            if (!_this.tickId) {
                _this.tickId = requestAnimationFrame(_this.tick);
            }
        };
        _this.handleResizeDebounce = simpleDebounce(_this.handleResize, 88);
        _this.getPublicScroll = memoize(function (scroll) { return (__assign({}, scroll)); }, function (_a, _b) {
            var a = _a[0];
            var b = _b[0];
            return shallowEqualScroll(a, b);
        });
        _this.getPublicDimensions = memoize(function (dimensions) { return (__assign({}, dimensions)); }, function (_a, _b) {
            var a = _a[0];
            var b = _b[0];
            return shallowEqualDimensions(a, b);
        });
        _this.syncState = function () {
            if (!_this.syncedStateOnce) {
                _this.syncedStateOnce = true;
            }
            if (_this.scrollMightHaveUpdated) {
                Object.assign(_this.scrollState, getClientScroll(_this.scrollState));
            }
            if (_this.resizeMightHaveUpdated) {
                Object.assign(_this.dimensionsState, getClientDimensions());
            }
            var scrollDidUpdate = _this.scrollMightHaveUpdated &&
                !shallowEqualScroll(_this.lastSyncedScrollState, _this.scrollState);
            var dimensionsDidUpdate = _this.resizeMightHaveUpdated &&
                !shallowEqualDimensions(_this.lastSyncedDimensionsState, _this.dimensionsState);
            if (scrollDidUpdate) {
                _this.lastSyncedScrollState = __assign({}, _this.scrollState);
            }
            if (dimensionsDidUpdate) {
                _this.lastSyncedDimensionsState = __assign({}, _this.dimensionsState);
            }
            if (scrollDidUpdate || dimensionsDidUpdate) {
                var publicState = _this.getPropsFromState();
                _this.props.onUpdate(publicState, {
                    scrollDidUpdate: scrollDidUpdate,
                    dimensionsDidUpdate: dimensionsDidUpdate,
                });
                _this.updateOnIdle(publicState, {
                    scrollDidUpdate: scrollDidUpdate,
                    dimensionsDidUpdate: dimensionsDidUpdate,
                });
            }
        };
        _this.updateOnIdle = debounceOnUpdate(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (typeof _this.props.onIdledUpdate === 'function') {
                (_a = _this.props).onIdledUpdate.apply(_a, args);
            }
        }, 166);
        _this.state = {
            parentProviderExists: false,
        };
        _this.scrollMightHaveUpdated = false;
        _this.resizeMightHaveUpdated = false;
        _this.scrollState = createEmptyScrollState();
        _this.dimensionsState = createEmptyDimensionState();
        _this.lastSyncedDimensionsState = __assign({}, _this.dimensionsState);
        _this.lastSyncedScrollState = __assign({}, _this.scrollState);
        _this.resizeObserver = null;
        _this.syncedStateOnce = false;
        return _this;
    }
    ViewportCollector.prototype.componentDidMount = function () {
        var options = browserSupportsPassiveEvents ? { passive: true } : false;
        window.addEventListener('scroll', this.handleScroll, options);
        window.addEventListener('resize', this.handleResizeDebounce, options);
        window.addEventListener('orientationchange', this.handleResizeDebounce, options);
        if (typeof window.ResizeObserver !== 'undefined') {
            this.resizeObserver = new window.ResizeObserver(this.handleResizeDebounce);
            this.resizeObserver.observe(document.body);
        }
        else {
            warnNoResizeObserver();
        }
        this.handleScroll();
        this.handleResize();
    };
    ViewportCollector.prototype.componentWillUnmount = function () {
        window.removeEventListener('scroll', this.handleScroll, false);
        window.removeEventListener('resize', this.handleResizeDebounce, false);
        window.removeEventListener('orientationchange', this.handleResizeDebounce, false);
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        if (typeof this.tickId === 'number') {
            cancelAnimationFrame(this.tickId);
        }
    };
    ViewportCollector.prototype.getPropsFromState = function () {
        return {
            scroll: this.getPublicScroll(this.lastSyncedScrollState),
            dimensions: this.getPublicDimensions(this.lastSyncedDimensionsState),
        };
    };
    ViewportCollector.prototype.render = function () {
        return null;
    };
    return ViewportCollector;
}(PureComponent));

var createFallbackViewportRequester = function () {
    var defaultValue;
    var lastAccess = 0;
    return function () {
        if (!defaultValue || now() - lastAccess > 1000) {
            defaultValue = {
                scroll: getClientScroll(),
                dimensions: getClientDimensions(),
            };
            lastAccess = now();
        }
        return defaultValue;
    };
};
var ViewportContext = createContext({
    removeViewportChangeListener: function (handler) { },
    scheduleReinitializeChangeHandler: function (handler) { },
    addViewportChangeListener: function (handler, options) { },
    getCurrentViewport: createFallbackViewportRequester(),
    hasRootProviderAsParent: false,
    version: '1.12.1',
});
var maxIterations = function (priority) {
    switch (priority) {
        case 'highest':
            return 0;
        case 'high':
            return 4;
        case 'normal':
            return 16;
        case 'low':
            return 64;
    }
};
var shouldSkipIteration = function (_a, budget) {
    var getPriority = _a.priority, averageExecutionCost = _a.averageExecutionCost, skippedIterations = _a.skippedIterations;
    var priority = getPriority();
    if (priority === 'highest') {
        return false;
    }
    if (priority !== 'low' && averageExecutionCost <= budget) {
        return false;
    }
    if (averageExecutionCost <= budget / 10) {
        return false;
    }
    var probability = skippedIterations / maxIterations(priority);
    if (probability >= 1) {
        return false;
    }
    return Math.random() > probability;
};
var ViewportProvider = /** @class */ (function (_super) {
    __extends(ViewportProvider, _super);
    function ViewportProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.listeners = [];
        _this.triggerUpdateToListeners = function (state, _a, options) {
            var scrollDidUpdate = _a.scrollDidUpdate, dimensionsDidUpdate = _a.dimensionsDidUpdate;
            var getOverallDuration = createPerformanceMarker();
            var _b = Object.assign({ isIdle: false, shouldInitialize: false }, options), isIdle = _b.isIdle, shouldInitialize = _b.shouldInitialize;
            var updatableListeners = _this.listeners.filter(function (_a) {
                var notifyScroll = _a.notifyScroll, notifyDimensions = _a.notifyDimensions, notifyOnlyWhenIdle = _a.notifyOnlyWhenIdle, skippedIterations = _a.skippedIterations, initialized = _a.initialized;
                var needsUpdate = skippedIterations > 0;
                if (notifyOnlyWhenIdle() !== isIdle && !needsUpdate) {
                    return false;
                }
                if (shouldInitialize && !initialized) {
                    return true;
                }
                var updateForScroll = notifyScroll() && scrollDidUpdate;
                var updateForDimensions = notifyDimensions() && dimensionsDidUpdate;
                return updateForScroll || updateForDimensions;
            });
            if (_this.props.experimentalSchedulerEnabled) {
                if (!isIdle) {
                    var budget_1 = 16 / updatableListeners.length;
                    updatableListeners = updatableListeners.filter(function (listener) {
                        var skip = listener.initialized
                            ? shouldSkipIteration(listener, budget_1)
                            : false;
                        if (skip) {
                            listener.skippedIterations++;
                            return false;
                        }
                        listener.skippedIterations = 0;
                        return true;
                    });
                }
            }
            var layouts = updatableListeners.map(function (_a) {
                var recalculateLayoutBeforeUpdate = _a.recalculateLayoutBeforeUpdate;
                if (recalculateLayoutBeforeUpdate) {
                    var getDuration = createPerformanceMarker();
                    var layoutState = recalculateLayoutBeforeUpdate(state);
                    return [layoutState, getDuration()];
                }
                return null;
            });
            var overallJSHandlerTotalCost = 0;
            updatableListeners.forEach(function (listener, index) {
                var handler = listener.handler, averageExecutionCost = listener.averageExecutionCost, iterations = listener.iterations;
                var _a = layouts[index] || [null, 0], layout = _a[0], layoutCost = _a[1];
                var getDuration = createPerformanceMarker();
                handler(state, layout);
                var totalCost = layoutCost + getDuration();
                var diff = totalCost - averageExecutionCost;
                var i = iterations + 1;
                listener.averageExecutionCost = averageExecutionCost + diff / i;
                listener.iterations = i;
                listener.initialized = true;
                overallJSHandlerTotalCost += totalCost;
            });
            if (_this.props.experimentalSchedulerLayoutCalculatorEnabled &&
                updatableListeners.length) {
                setTimeout(function () {
                    var diffPerHandler = (getOverallDuration() - overallJSHandlerTotalCost) /
                        updatableListeners.length;
                    updatableListeners.forEach(function (listener) {
                        listener.averageExecutionCost =
                            listener.averageExecutionCost +
                                diffPerHandler / listener.iterations;
                    });
                }, 0);
            }
        };
        _this.addViewportChangeListener = function (handler, options) {
            _this.listeners.push(__assign({ handler: handler, iterations: 0, averageExecutionCost: 0, skippedIterations: 0, initialized: false }, options));
            _this.handleListenerUpdate();
        };
        _this.scheduleReinitializeChangeHandler = function (h) {
            var listener = _this.listeners.find(function (_a) {
                var handler = _a.handler;
                return handler === h;
            });
            if (listener && listener.initialized) {
                listener.initialized = false;
                _this.handleListenerUpdate();
            }
        };
        _this.removeViewportChangeListener = function (h) {
            _this.listeners = _this.listeners.filter(function (_a) {
                var handler = _a.handler;
                return handler !== h;
            });
            _this.handleListenerUpdate();
        };
        _this.collector = createRef();
        _this.getCurrentDefaultViewport = createFallbackViewportRequester();
        _this.contextValue = {
            addViewportChangeListener: _this.addViewportChangeListener,
            removeViewportChangeListener: _this.removeViewportChangeListener,
            scheduleReinitializeChangeHandler: _this.scheduleReinitializeChangeHandler,
            getCurrentViewport: function () {
                if (_this.collector.current && _this.collector.current.syncedStateOnce) {
                    return _this.collector.current.getPropsFromState();
                }
                return _this.getCurrentDefaultViewport();
            },
            hasRootProviderAsParent: true,
            version: '1.12.1',
        };
        _this.renderChildren = function (props) {
            if (props.hasRootProviderAsParent) {
                if (process.env.NODE_ENV !== 'production' &&
                    props.version !== '1.12.1') {
                    console.warn("react-viewport-utils: Two different versions of the react-viewport-utils library are used in the same react tree. This can lead to unexpected results as the versions might not be compatible.\nThe <ViewportProvider> of version " + props.version + " is currently used, another <ViewportProvider> of version 1.12.1 was detected but is ignored.\nThis is most probably due to some dependencies that use different versions of the react-viewport-utils library. You can check if an update is possible.");
                }
                return _this.props.children;
            }
            return (createElement(Fragment, null,
                _this.state.hasListeners && (createElement(ViewportCollector, { ref: _this.collector, onUpdate: _this.triggerUpdateToListeners, onIdledUpdate: function (state, updates) {
                        return _this.triggerUpdateToListeners(state, updates, { isIdle: true });
                    } })),
                createElement(ViewportContext.Provider, { value: _this.contextValue }, _this.props.children)));
        };
        _this.state = {
            hasListeners: false,
        };
        return _this;
    }
    ViewportProvider.prototype.componentWillUnmount = function () {
        if (typeof this.updateListenersTick === 'number') {
            clearTimeout(this.updateListenersTick);
        }
        if (typeof this.initializeListenersTick === 'number') {
            cancelAnimationFrame(this.initializeListenersTick);
        }
    };
    ViewportProvider.prototype.handleListenerUpdate = function () {
        var _this = this;
        if (this.updateListenersTick === undefined) {
            this.updateListenersTick = setTimeout(function () {
                var nextState = _this.listeners.length !== 0;
                if (_this.state.hasListeners !== nextState) {
                    _this.setState({
                        hasListeners: _this.listeners.length !== 0,
                    });
                }
                _this.updateListenersTick = undefined;
            }, 1);
        }
        if (this.initializeListenersTick === undefined) {
            this.initializeListenersTick = requestAnimationFrame(function () {
                if (_this.collector.current &&
                    _this.collector.current.syncedStateOnce &&
                    _this.listeners.some(function (l) { return !l.initialized; })) {
                    _this.triggerUpdateToListeners(_this.collector.current.getPropsFromState(), {
                        dimensionsDidUpdate: false,
                        scrollDidUpdate: false,
                    }, {
                        isIdle: false,
                        shouldInitialize: true,
                    });
                }
                _this.initializeListenersTick = undefined;
            });
        }
    };
    ViewportProvider.prototype.render = function () {
        return (createElement(ViewportContext.Consumer, null, this.renderChildren));
    };
    return ViewportProvider;
}(PureComponent));

var ObserveViewport = /** @class */ (function (_super) {
    __extends(ObserveViewport, _super);
    function ObserveViewport(props) {
        var _this = _super.call(this, props) || this;
        _this.handleViewportUpdate = function (viewport, layoutSnapshot) {
            if (_this.props.onUpdate) {
                _this.props.onUpdate(viewport, layoutSnapshot);
            }
            if (_this.props.children) {
                _this.syncState(viewport);
            }
        };
        _this.registerViewportListeners = function (_a) {
            var addViewportChangeListener = _a.addViewportChangeListener, removeViewportChangeListener = _a.removeViewportChangeListener, scheduleReinitializeChangeHandler = _a.scheduleReinitializeChangeHandler, hasRootProviderAsParent = _a.hasRootProviderAsParent, getCurrentViewport = _a.getCurrentViewport;
            if (!hasRootProviderAsParent) {
                warnNoContextAvailable('ObserveViewport');
                return null;
            }
            var shouldRegister = _this.removeViewportChangeListener !== removeViewportChangeListener;
            if (!shouldRegister) {
                return null;
            }
            if (_this.removeViewportChangeListener) {
                _this.removeViewportChangeListener(_this.handleViewportUpdate);
            }
            _this.removeViewportChangeListener = removeViewportChangeListener;
            _this.scheduleReinitializeChangeHandler = scheduleReinitializeChangeHandler;
            addViewportChangeListener(_this.handleViewportUpdate, {
                notifyScroll: function () { return !_this.props.disableScrollUpdates; },
                notifyDimensions: function () { return !_this.props.disableDimensionsUpdates; },
                notifyOnlyWhenIdle: function () { return _this.props.deferUpdateUntilIdle; },
                priority: function () { return _this.props.priority; },
                recalculateLayoutBeforeUpdate: function (viewport) {
                    if (_this.props.recalculateLayoutBeforeUpdate) {
                        return _this.props.recalculateLayoutBeforeUpdate(viewport);
                    }
                    return null;
                },
            });
            if (_this.props.children) {
                _this.syncState(getCurrentViewport());
            }
            return null;
        };
        _this.state = {
            scroll: createEmptyScrollState(),
            dimensions: createEmptyDimensionState(),
        };
        return _this;
    }
    ObserveViewport.prototype.componentDidUpdate = function (prevProps) {
        var dimensionsBecameActive = !this.props.disableDimensionsUpdates &&
            prevProps.disableDimensionsUpdates;
        var scrollBecameActive = !this.props.disableScrollUpdates && prevProps.disableScrollUpdates;
        if (typeof this.scheduleReinitializeChangeHandler === 'function' &&
            (dimensionsBecameActive || scrollBecameActive)) {
            this.scheduleReinitializeChangeHandler(this.handleViewportUpdate);
        }
    };
    ObserveViewport.prototype.componentWillUnmount = function () {
        if (this.removeViewportChangeListener) {
            this.removeViewportChangeListener(this.handleViewportUpdate);
        }
        this.removeViewportChangeListener = undefined;
        this.scheduleReinitializeChangeHandler = undefined;
        if (typeof this.tickId === 'number') {
            cancelAnimationFrame(this.tickId);
        }
    };
    ObserveViewport.prototype.syncState = function (nextViewport) {
        var _this = this;
        this.nextViewport = nextViewport;
        if (this.tickId === undefined) {
            this.tickId = requestAnimationFrame(function () {
                if (_this.nextViewport) {
                    _this.setState(_this.nextViewport);
                }
                _this.tickId = undefined;
                _this.nextViewport = undefined;
            });
        }
    };
    Object.defineProperty(ObserveViewport.prototype, "optionNotifyScroll", {
        get: function () {
            return !this.props.disableScrollUpdates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObserveViewport.prototype, "optionNotifyDimensions", {
        get: function () {
            return !this.props.disableDimensionsUpdates;
        },
        enumerable: true,
        configurable: true
    });
    ObserveViewport.prototype.render = function () {
        var children = this.props.children;
        return (createElement(Fragment, null,
            createElement(ViewportContext.Consumer, null, this.registerViewportListeners),
            children ? children(this.state) : null));
    };
    ObserveViewport.defaultProps = {
        disableScrollUpdates: false,
        disableDimensionsUpdates: false,
        deferUpdateUntilIdle: false,
        priority: 'normal',
    };
    return ObserveViewport;
}(Component));

function connect(options) {
    if (options === void 0) { options = {}; }
    var deferUpdateUntilIdle = Boolean(options.deferUpdateUntilIdle);
    var omit = options.omit || [];
    var shouldOmitScroll = omit.indexOf('scroll') !== -1;
    var shouldOmitDimensions = omit.indexOf('dimensions') !== -1;
    return function (WrappedComponent) {
        var _a;
        var displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
        return _a = /** @class */ (function (_super) {
                __extends(ConnectViewport, _super);
                function ConnectViewport() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ConnectViewport.prototype.render = function () {
                    var _this = this;
                    return (createElement(ObserveViewport, { disableScrollUpdates: shouldOmitScroll, disableDimensionsUpdates: shouldOmitDimensions, deferUpdateUntilIdle: deferUpdateUntilIdle, priority: options.priority }, function (_a) {
                        var scroll = _a.scroll, dimensions = _a.dimensions;
                        return (createElement(WrappedComponent, __assign({ scroll: scroll, dimensions: dimensions }, _this.props)));
                    }));
                };
                return ConnectViewport;
            }(Component)),
            _a.displayName = "connectViewport(" + displayName + ")",
            _a;
    };
}

/**
 * @deprecated Use useRect or useRectEffect instead as it provides better performance.
 */
var ObserveBoundingClientRect = /** @class */ (function (_super) {
    __extends(ObserveBoundingClientRect, _super);
    function ObserveBoundingClientRect(props) {
        var _this = _super.call(this, props) || this;
        _this.syncState = function () {
            var node = _this.props.node;
            if (!node || !node.current) {
                return;
            }
            var rect = _this.getRectFromNode();
            if (rect && !_this.state.isInitialized) {
                _this.setState(__assign(__assign({}, rect), { isInitialized: true }));
                return;
            }
            _this.setState(rect);
        };
        _this.state = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            height: 0,
            width: 0,
            isInitialized: false,
        };
        return _this;
    }
    ObserveBoundingClientRect.prototype.componentDidMount = function () {
        this.tick(this.syncState);
    };
    ObserveBoundingClientRect.prototype.componentDidUpdate = function (prevProps, prevState) {
        var rect = this.getRectFromState();
        var prevRect = this.getRectFromState(prevState);
        if (!rect) {
            return;
        }
        if (this.props.onInit) {
            if (!prevState.isInitialized && this.state.isInitialized) {
                this.props.onInit(rect);
            }
        }
        if (this.props.onUpdate) {
            if (prevRect === null || !shallowEqualRect(rect, prevRect)) {
                this.props.onUpdate(rect);
            }
        }
    };
    ObserveBoundingClientRect.prototype.componentWillUnmount = function () {
        if (typeof this.tickId === 'number') {
            cancelAnimationFrame(this.tickId);
        }
    };
    ObserveBoundingClientRect.prototype.tick = function (updater) {
        var _this = this;
        this.tickId = requestAnimationFrame(function () {
            updater();
            _this.tick(updater);
        });
    };
    ObserveBoundingClientRect.prototype.getRectFromState = function (state) {
        if (state === void 0) { state = this.state; }
        if (!state.isInitialized) {
            return null;
        }
        return {
            height: state.height,
            width: state.width,
            top: state.top,
            bottom: state.bottom,
            left: state.left,
            right: state.right,
        };
    };
    ObserveBoundingClientRect.prototype.getRectFromNode = function () {
        var node = this.props.node;
        if (!node || !node.current) {
            return null;
        }
        var rect = node.current.getBoundingClientRect();
        return {
            height: rect.height,
            width: rect.width,
            top: rect.top,
            bottom: rect.bottom,
            left: rect.left,
            right: rect.right,
        };
    };
    ObserveBoundingClientRect.prototype.render = function () {
        var children = this.props.children;
        return typeof children === 'function'
            ? children(this.getRectFromState())
            : null;
    };
    return ObserveBoundingClientRect;
}(PureComponent));

function useViewportEffect(handleViewportChange, second, third) {
    var _a = useContext(ViewportContext), addViewportChangeListener = _a.addViewportChangeListener, removeViewportChangeListener = _a.removeViewportChangeListener, hasRootProviderAsParent = _a.hasRootProviderAsParent;
    var _b = sortArgs(second, third), options = _b.options, deps = _b.deps;
    var memoOptions = useOptions(options);
    useEffect(function () {
        if (!hasRootProviderAsParent) {
            warnNoContextAvailable('useViewport');
            return;
        }
        addViewportChangeListener(handleViewportChange, {
            notifyScroll: function () { return !memoOptions.disableScrollUpdates; },
            notifyDimensions: function () { return !memoOptions.disableDimensionsUpdates; },
            notifyOnlyWhenIdle: function () { return Boolean(memoOptions.deferUpdateUntilIdle); },
            priority: function () { return memoOptions.priority || 'normal'; },
            recalculateLayoutBeforeUpdate: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return memoOptions.recalculateLayoutBeforeUpdate
                    ? memoOptions.recalculateLayoutBeforeUpdate.apply(memoOptions, args) : null;
            },
        });
        return function () { return removeViewportChangeListener(handleViewportChange); };
    }, __spreadArrays([
        addViewportChangeListener || null,
        removeViewportChangeListener || null
    ], deps));
}
var useViewport = function (options) {
    if (options === void 0) { options = {}; }
    var getCurrentViewport = useContext(ViewportContext).getCurrentViewport;
    var _a = useState(getCurrentViewport()), state = _a[0], setViewport = _a[1];
    useViewportEffect(function (viewport) { return setViewport(viewport); }, options);
    return state;
};
function useScrollEffect(effect, second, third) {
    var _a = sortArgs(second, third), options = _a.options, deps = _a.deps;
    useViewportEffect(function (viewport, snapshot) { return effect(viewport.scroll, snapshot); }, __assign({ disableDimensionsUpdates: true }, options), deps);
}
var useScroll = function (options) {
    if (options === void 0) { options = {}; }
    var scroll = useViewport(__assign({ disableDimensionsUpdates: true }, options)).scroll;
    return scroll;
};
function useDimensionsEffect(effect, second, third) {
    var _a = sortArgs(second, third), options = _a.options, deps = _a.deps;
    useViewportEffect(function (viewport, snapshot) { return effect(viewport.dimensions, snapshot); }, __assign({ disableScrollUpdates: true }, options), deps);
}
var useDimensions = function (options) {
    if (options === void 0) { options = {}; }
    var dimensions = useViewport(__assign({ disableScrollUpdates: true }, options)).dimensions;
    return dimensions;
};
function useRectEffect(effect, ref, third, fourth) {
    var _a = sortArgs(third, fourth), options = _a.options, deps = _a.deps;
    useViewportEffect(function (_, snapshot) { return effect(snapshot); }, __assign(__assign({}, options), { recalculateLayoutBeforeUpdate: function () {
            return ref.current ? ref.current.getBoundingClientRect() : null;
        } }), __spreadArrays([ref.current], deps));
}
function useRect(ref, second, third) {
    var _a = sortArgs(second, third), options = _a.options, deps = _a.deps;
    return useLayoutSnapshot(function () { return (ref.current ? ref.current.getBoundingClientRect() : null); }, options, __spreadArrays([ref.current], deps));
}
function useLayoutSnapshot(recalculateLayoutBeforeUpdate, second, third) {
    var _a = sortArgs(second, third), options = _a.options, deps = _a.deps;
    var _b = useState(null), state = _b[0], setSnapshot = _b[1];
    useViewportEffect(function (_, snapshot) { return setSnapshot(snapshot); }, __assign(__assign({}, options), { recalculateLayoutBeforeUpdate: recalculateLayoutBeforeUpdate }), deps);
    return state;
}
var useOptions = function (o) {
    var optionsRef = useRef(Object.create(null));
    for (var _i = 0, _a = Object.keys(optionsRef.current); _i < _a.length; _i++) {
        var key = _a[_i];
        delete optionsRef.current[key];
    }
    Object.assign(optionsRef.current, o);
    return optionsRef.current;
};
var sortArgs = function (first, second) {
    var options = {};
    if (first && !Array.isArray(first)) {
        options = first;
    }
    var deps = second || [];
    if (first && Array.isArray(first)) {
        deps = first;
    }
    return { deps: deps, options: options };
};

var VERSION = '1.12.1';

export { ObserveBoundingClientRect, ObserveViewport, VERSION, ViewportProvider, cancelAnimationFrame, connect as connectViewport, requestAnimationFrame, useDimensions, useDimensionsEffect, useLayoutSnapshot, useRect, useRectEffect, useScroll, useScrollEffect, useViewport, useViewportEffect };
//# sourceMappingURL=index.es.js.map
